effect ask('a) {
    val default : int
    fn ask(int, int) : 'a
}

type option('a) = 
    | none
    | some('a)

type struct('a) = {
    x: 'a,
    s: string
}

external print(int, string) : _ bool = ""

fun (10 | _) -> 10

let x = fun () -> 10 in
x()
let m = map(x) fun n -> n + 1;
match t {
    .some(_)
    _
    ask { }
    x
}


external `+`(int, int) : int = "kyoumi_int_add"
external `-`(int, int) : int = "kyoumi_int_minus
external ! ()


fn ask(x: int, x: 'a) : (ask<'a>) option<'a> =
    let x = perform();

let x = @array(1, 2, 4, 8)
ley y = 1::2::[]
    
fn map(l: list<'a>, mapper: fn('a) -> `a 'b ) : `b list('b) = 
    match l {
        | [] -> []
        | t::q -> {}
    }

fn dummy() : unit = 
    let x = map(x) 
        {  }
            fold(x) fun 

type coordinate = {
    x: int,
    y: int
}

fn main() : (io & exn & out_mem) int = 
    let x = coordinate.{ x, y};
    let handler = handler ask<int> {
        let default = 10;
        fn ask(x: int, y : int) = x + y;
    }

    let x = match List.map(x) fun((x, y), d) -> x + 1 end ;
    let x = 

    let () = &ask.ask();

    let y = Operator.`+`.(10, 20)

    let x = ask() with handler ; 

    let x = fun x y -> x + y in  
    let x = 19;
    let () = match x {
        _ => 
    };
    10
